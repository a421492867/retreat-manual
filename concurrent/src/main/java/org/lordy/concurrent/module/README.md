### 基础模块构建

> 同步容器类  
> - 将它们的状态封装起来 并对每个公有方法都进行同步 使得每一次只有一个线程能访问容器的状态
> 
> 并发容器  改进同步容器的性能
- ConcurrentHashMap 
- CopyOnWriteArrayList 每次修改时 都会创建并重新发布一个新的副本容器 (事件通知系统)
- 阻塞队列和生产者-消费者模式
- 双端队列与工作密取

> 阻塞方法与中断方法
> 线程可能会阻塞或暂停执行 原因有多种 ： 等待I/O操作结束、等待获得一个锁、等待从Thread.sleep方法中醒来、等待另一个线程的计算结果
> 阻塞状态（BLOCKED、WAITING、TIMED_WAITING）
> 被阻塞的线程必须等待某个不受它控制的事件发生后才能继续执行 回置RUNNABLE状态 可再次被调度执行
> 
> interrupt方法 用于中断线程或者查询线程是否已经被中断
> 中断是一种协作机制。一个线程不能强制其他线程停止正在执行的操作而去执行其他操作
> 当线程A中断B时 A仅仅要求B在执行到某个可以暂停的地方停止正在执行的操作 前提是如果线程B愿意停止下来 
> 中断情况一般就是取消某个操作
> 当在代码中调用了一个将抛出InterruptedException异常的方法时 你自己的方法也就变成了一个阻塞方法 必须要处理中断的响应 方法如下
- 1、传递InterruptedException  将InterruptedException传递给方法调用者 1）不捕获该异常 2）捕获异常 然后再执行某种简单清理工作后再次抛出这个异常
- 2、恢复中断  调用当前线程interrupt方法恢复中断状态 调用栈中更高层的代码可以看到引发了一个中断

> 同步工具类   根据自身状态来协调线程控制流
（封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待； 提供了一些方法对状态进行操作； 用于高效地等待同步工具类进入到预期状态的方法）
> 
- 1、闭锁 可以延迟线程的进度直到其达到终止状态 （相当于一扇门 在闭锁达到结束状态之前，这扇门一直关闭 并且没有任何线程能够通过 当达到结束状态时 这扇门会打开并允许所有线程通过 当闭锁达到状态结束后 将不会再改变状态 这扇门永远保持打开状态）
- 闭锁可以用来确保某些活动直到其他活动都完成后才继续进行
- CountDownLatch
- 
- 2、FutureTask（也可以用做闭锁）

- 3、信号量  控制同时访问某个特定资源的操作数量 或者同时执行某个操作的数量
- Semaphore中管理一组虚拟的许可 许可初始数量可以通过构造函数指定。 在执行操作时首先获得许可（只要还有剩余的许可），并在使用以后释放许可。如果没有许可，那么acquire将阻塞直到有许可（或者被中断 或者操作超时） release方法将返回一个许可给信号量
- 简化形式是二值信号量 初始许可为1  用做互斥体

- 4、栅栏 栅栏类似于闭锁 它能阻塞一组线程直到某个事情发生 与闭锁的区别在于 所有线程必须同时到达栅栏的位置 才能继续执行  闭锁用于等待事件 而栅栏用于等待线程 （所有人6：00在麦当劳碰头 到了以后等其他人 之后再讨论下一步事情）
- CyclicBarrier
- Exchanger （两方栅栏 各自在栅栏位置上交换数据）

> 高效且可伸缩的结果缓存
> 
> 
> 
### shared safety combination module小结
> 可变状态是至关重要的  所有并发问题都可以归纳为如何协调对并发状态的访问 可变状态越少 就越容易确保线程安全
> 尽量将域声明为final类型 除非需要他们是可变的
> 不可变对象一定是线程安全的
> 封装有助于管理复杂性
> 用锁来保护每个变量
> 当保护同一个不变形条件中的所有变量时 要使用同一个锁
> 在执行符合操作期间 要持有锁
> 如果从多个线程中访问同一个可变变量时没有同步机制 那么程序可能会出现问题
> 