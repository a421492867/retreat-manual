> 可见性
> - 我们无法确保执行读操作的线程能适时地看到其他线程写入的值,有时候甚至是不可能的事情 为了确保多个线程之间对内存写入操作的可见性,必须使用同步机制
> 
> 重排序
> 
- 当线程在没有同步的情况下读取变量时，可能会看到一个失效值 但至少这个值是由之前某个线程设置的 而不是一个随机值 这种安全性保证被称为最低安全性

> 非原子64位操作
> - 非volatile类型的64位数值变量(double 和 long) Java内存模型要求 变量的读取操作和写入操作都必须是原子操作,但对于非volatile的long和double,JVM允许将64位的读操作或写操作分解为两个32位的操作 当读取一个非volatile的long时 如果对该变量的读和写不在同一个线程 那么很可能会读到某个值的高32位和另一个值的低32位
> 
> 内置锁可以确保某个线程以一种可预测的方式来查看另一个线程的执行结果
> 
> volatile通常用做某个操作完成、发生或者中断的标志
> 
> *** 加锁机制既可以确保可见性又可以确保原子性 而volatile变量只能确保可见性
> 
> 
### 发布与逸出
> 发布 : 使对象能够在当前作用域之外的代码中使用  例如 将一个指向该对象的引用保存到其他代码可以访问的地方 或者在某一个非私有的方法中返回该引用 或者将引用传递到其他类的方法中
> 逸出 : 某个不应该发布的对象被发布
> 
> 
### 线程封闭
> 当访问共享的可变数据时，通常需要使用同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭
> - 当某个对象封闭在一个线程时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。
> 常见应用 ： Swing  JDBC的Connection
> 
> Ad-hoc线程封闭 ： 维护线程封闭性的职责完全由程序来承担
> 栈封闭 ： 只能通过局部变量才能访问对象  如果在线程内部上下文中使用非线程安全对象，那么该对象依然时线程安全的
> ThreadLocal类 ： 维持线程封闭性更规范的方法  通常用于防止对可变的单例变量或全局变量进行共享
> 
### 不可变对象
> 某个对象在创建后其状态就不能被修改，称为不可变对象
> 不可变对象一定是线程安全的
> 
> 满足以下条件 对象不可变：
- 1、对象创建后其状态就不能改变
- 2、对象的所有域都是final类型**（从技术上看不一定）
- 3、对象是正确创建的（this引用没有逸出）