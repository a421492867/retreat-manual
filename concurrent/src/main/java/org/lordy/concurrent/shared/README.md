> 可见性
> - 我们无法确保执行读操作的线程能适时地看到其他线程写入的值,有时候甚至是不可能的事情 为了确保多个线程之间对内存写入操作的可见性,必须使用同步机制
> 
> 重排序
> 
- 当线程在没有同步的情况下读取变量时，可能会看到一个失效值 但至少这个值是由之前某个线程设置的 而不是一个随机值 这种安全性保证被称为最低安全性

> 非原子64位操作
> - 非volatile类型的64位数值变量(double 和 long) Java内存模型要求 变量的读取操作和写入操作都必须是原子操作,但对于非volatile的long和double,JVM允许将64位的读操作或写操作分解为两个32位的操作 当读取一个非volatile的long时 如果对该变量的读和写不在同一个线程 那么很可能会读到某个值的高32位和另一个值的低32位
> 
> 内置锁可以确保某个线程以一种可预测的方式来查看另一个线程的执行结果
> 
> volatile通常用做某个操作完成、发生或者中断的标志
> 
> *** 加锁机制既可以确保可见性又可以确保原子性 而volatile变量只能确保可见性
> 
> 
### 发布与逸出
> 发布 : 使对象能够在当前作用域之外的代码中使用  例如 将一个指向该对象的引用保存到其他代码可以访问的地方 或者在某一个非私有的方法中返回该引用 或者将引用传递到其他类的方法中
> 逸出 : 某个不应该发布的对象被发布
> 
> 
### 线程封闭