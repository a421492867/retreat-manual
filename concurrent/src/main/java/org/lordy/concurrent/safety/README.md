> 线程的安全性
- 当多个线程访问某个类时，这个类始终能表现出正确的行为，那么就称这个类是线程安全的（多少有点 听君一席话 胜似一席话的意思）
- 竞态条件 ： 由于不恰当的执行时序而出现不正确的结果 （先检查后执行 ： 基于一种可能失效的观察结果来做判断或者执行某个计算）
> 活跃性
> 性能
- 要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性、简单性和性能，需要找到几者之间的平衡


### 内置锁
> Java提供一种内置锁机制来支持原子性 : 同步代码块(Synchronized Block)
> 内置锁是可重入的  当某个线程试图获得一个已经由它自己持有的锁,那么这个请求会成功
> "重入"意味着获取锁的操作粒度是"线程" 而不是 "调用"
>
> 重入的一种实现方法 : 为每个锁关联一个 获取计数值 和 一个 所有者线程 当计数值为0 这个锁就被认为是没有任何线程持有.当线程请求一个未被持有的锁时,JVM记下锁的持有者 并且将获取计数值置为1 如果同一个线程再次获得这个锁,计数值递增,而当线程退出同步代码块时,计数值会相应递减,当计数值为0 这个锁被释放

对于可能被多个线程同时访问的可变状态量，在访问它时都需要持有同一个锁，这种情况下，我们称 状态变量 由 这个锁 保护