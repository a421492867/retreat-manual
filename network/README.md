# 网络

### 网络基础
> TCP/IP 通常使用的网络是在TCP/IP协议族的基础上运作的 HTTP属于其内部的一个子集
- TCP/IP最重要的一点就是分层 按层次分为 应用层 传输层 网络层  数据链路层
- 应用层 ：决定了向用户提供应用服务时通信的活动 （FTP、DNS） HTTP协议处于该层
- 传输层 ：提供处于网络链接中两台计算机之间的数据传输 有两个性质不同的协议 TCP（传输控制协议） 和 UDP（用户数据报协议）
- 网络层 ：用来处理在网络上流动的数据包 数据包是网络传输最小的数据单位 该层规定通过怎样的路径到达对方计算机 并把数据包给对方（选择传输路线）
- 数据链路层 ：用来处理链接网络的硬件部分

> TCP/IP通信传输流
> ![avatar](./img/通信传输流.png)
- 发送端在层与层之间传输数据时 每经过一层必定会被打上一个该层所属的首部信息 反之则消去首部信息
> 
> 与HTTP相关的协议 IP TCP DNS
- 负责传输的IP协议
- ``` ip协议位于网络层  作用是把各种数据包传送给对方 要确保确实传送到对方那里 需要各种条件 其中最重要的就是IP地址和MAC地址 ```
- 确保可靠性的TCP协议
- ``` TCP位于传输层 提供可靠的字节流服务（大块数据分割成以报文段为单位的数据包进行管理） 能够把数据准确可靠的传给对方 为了确保准确 TCP协议采用三次握手策略 ```
- #### 三次握手
- 发送端首先发送一个带SYN标志的数据包给对方 接收端收到后 回传一个带有SYN/ACK标志的数据包以示传达确认信息 最后发送端再回传一个带ACK标志的数据包 以表握手结束 若在握手过程中某个阶段中断 TCP协议会再次以相同顺序发送相同数据包
- ![avatar](./img/三次握手.png)

> 负责域名解析的DNS服务
> - DNS位于应用层 提供域名到IP地址的解析服务
> 
> 
### 端到端的通信是应用进程之间的通信


### 面向连接的TCP 和 无连接的UDP
> 两个对等运输实体在通信时传送的数据单位叫做 运输协议数据单元 根据所使用的协议 分别称TCP报文段 和 UDP用户数据
> UDP传达数据之前不需要建立连接（不提供可靠交付）
> TCP提供面向连接的服务 不提供广播或多播服务 可靠的

#### UDP
> 主要特点：1、UDP是无连接的 发送数据之前不需要建立连接 2、UDP使用尽最大努力交付 即不保证可靠交付 3、UDP是面向报文的 4、UDP没有拥塞控制 5、支持一对一、一对多、多对一、多对多的交互通信 6、UDP首部开销小（8个字节）
* UDP一次发送一个报文 一次交付一个完整的报文  若报文太长 UDP把它交给IP层后 IP层在传输时可能要进行分片 会降低IP层效率 若太短 会使IP数据报的首部的相对长度太大 也降低IP效率

#### TCP
> 主要特点：1、面向连接  2、每一条TCP连接只能有两个端点 每条TCP连接只能是点对点（一对一） 3、提供可靠交付的服务 4、提供全双工通信 5、面向字节流
* 使用TCP之前需要先建立TCP连接 数据传输完毕后释放TCP连接
* 可靠交付 ： 无差错 不丢失 不重复 按序到达
* 全双工通信：TCP允许通信双方的应用程序在任何时候都能发送数据 TCP连接两端都设有发送缓存和接收缓存 用来临时存放双向通信的数据
* 面向字节流：虽然应用程序和TCP的交互是一次一个数据块 但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流 TCP并不知道所传送的字节流的含义  接收方应用程序收到的字节流必须和发送方应用程序发送的字节流完全一致
* TCP根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应该包含多少个字节

##### TCP的连接
- TCP连接的端点叫做套接字 端口号拼接到IP地址即构成了套接字
- 每一条TCP连接唯一地被通信两端的两个端点（即两个套接字）所确定  TCP连接::={socket1, socket2} == {(ip1:port1),(ip2:port2)}

##### 可靠传输的工作原理
理想的传输条件有两个特点：1、传输信道不产生差错 2、不管发送方以多快的速度发送数据，接收方总来得及处理收到的数据

> 停止等待协议
> 1、无差错情况
> ![avatar](./img/停止等待无差错.png)
> 2、出现差错
> ``` 上图b是分组在传输过程中出现差错的情况 B接收M1时检查出了差错 就丢弃了M1 其他什么也不做 也可能是M1在传输过程中丢失了 这时B也什么都不知道。 在这两种情况下 B都不会发送任何信息 可靠传输协议时这样设计的：A只要超过一段时间仍然没有收到确认 就认为刚才发送的分组丢失了 因而重传前面发送过的分组 这叫做超时重传 需要设置超时计时器 如果在超时计时器到期前收到了对方的确认 就撤销这个分组的超时计时器```
> ``` A在发送完一个分组后 必须暂时保留已发送的分组副本 只有收到确认后才能清除；  分组和确认分组都必须进行编号 这样才能明确哪一个发出去的分组收到了确认 哪一个没有；  超时计时器设置的重传时间应当比数据在分组传输的平均往返时间更长一些```
> 3、确认丢失和确认迟到
> ![avatar](./img/停止等待确认丢失和迟到.png)
> ```图a表示确实丢失 A没有收到确认且超过了超时时间 也无法知道是自己发出的分组出错、丢失还是确认丢失了， A重传M1， B又收到了M1 应该采取两个行动 ： 1、丢弃这个分组M1 2、向A发送确认```
> ``` 图b表示确认迟到  A会收到重复的确认 A处理方式很简单，收下后就丢弃 B仍会收到重复的M1 丢弃并重传确认```
> 
> 使用上述确认和重传机制 就可以在不可靠的传输网络上实现可靠的通信 这种协议通常称为 自动重传请求ARQ（Automatic Repeat Request）  重传的请求是自动进行的
> 停止等待协议效率低
> ![avatar](./img/停止等待效率.png)
> 为了提高传输效率 采用流水线传输  发送方可以连续发送多个分组 不必每发完一个分组就停下来等待确认（连续ARQ协议 和 滑动窗口协议）
> ![avatar](./img/流水线.png)

> 连续ARQ协议
> ![avatar](./img/连续ARQ.png)
> 发送方每收到一个确认 就把发送窗口向前滑动一个分组的位置  接收方一般采用累计确认的方式  接收方不必对收到的分组逐个发送确认 而是在收到几个分组后 对按序到达的最后一个分组发送确认 代表到这个分组为止的所有分组已正确收到 
> 
##### TCP报文段首部格式
> ![avatar](./img/TCP首部.png)
> 前20字节固定  因此TCP首部最小长度是20字节 4n的选项长度不能超过40字节 也就是TCP首部最大长度是60字节
> 控制位 ：1、确认ACK 仅当ACK = 1时确认号字段才有效  TCP规定，在连接建立后所有传送报文段都必须把ACK置1。  2、同步SYN 在建立连接时用来同步序号 当SYN = 1而ACK = 0时 表明这是一个连接请求报文段 若对方同意连接 响应报文段中SYN = 1 和 ACK = 1  3、窗口  允许对方发送的数据量
> 

