# Java对象创建

## 对象的实例化

### 对象创建方式

> 1.new :  Object o = new Object();
>
> 2.Class的newInstance方法
>
> 3.Constructor的newInstance方法
>
> 4.clone方法
>
> 5.序列化
>
> 6.第三方库Objenesis 使用字节码动态生成

### 对象创建的步骤

> 1.判断对象对应的类是否加载 链接 初始化
>
> *虚拟机遇到一条new指令 首先检查这个指令的参数能否在Metaspace的常量池中定位到一个类的符号引用 并且检查这个符号引用代表的类是否已经被加载 解析和初始化*
>
> *如果类没有被加载 那么在双亲委派模式下 加载类*
>
> 2.为对象分配内存
>
> *计算对象占用空间的大小 在堆中划分一块内存给新对象 如果实例成员变量是引用变量 仅分配引用变量空间(4个字节)  开始分配这个空间*
>
> *如果内存规整  采用指针碰撞法为对象分配内存  即有所用过的内存在一边 空闲的内存放在另一边 没有碎片或者碎片不严重 中间放着一个指针作为分界点的指示器 分配内存就仅仅是吧指针往空闲内存那边移动一段与对象相等的距离;*
>
> *如果内存不规整  采用空闲列表来分配对象内存  即 虚拟机维护一个列表 记录哪些内存块是可用的 分配的时候从列表中找到一块足够大的空间分配给对象实例 并更新列表内容*
>
> 3.处理并发问题
>
> *由于堆空间是线程共享的 需要处理并发问题*
>
> *(1)采用CAS+失败重试保证更新的原子性*
>
> *(2)每个线程预先分配TLAB 即区域加锁机制*
>
> 4.初始化分配到的空间
>
> *所有属性设置默认值  给属性赋值的顺序如下*
>
> *(1)先给属性的默认值初始化 全部附上默认值*
>
> (2)初始化/代码块初始化  自己已经写了赋值的
>
> (3)构造器初始化
>
> 5.设置对象的对象头
>
> *将对象的所属类 HashCode GC信息 锁信息等数据存储在对象头*
>
> 6.执行init方法进行初始化 显示赋值  上边的赋值是默认值
>
> *初始化正式开始 初始化成员变量 执行实例化代码块 调用类的构造方法 并把堆内对象的首地址赋值给引用变量*

## 对象的内存布局

> 1.对象头
>
>*(1) 运行时元数据 MarkWord  : HashCode  GC分代年龄  锁状态标志  线程持有的锁  偏向锁Id  偏向时间戳*
>
>*(2) 类型指针 : 指向类元数据InstanceKlass 确定该对象所属的类型*
>
>*(3) 如果是数组 还需要记录数组的长度*
>
>2.实例数据
>
>*对象真正存储的有效信息 包括代码中定义的各种类型的字段 包括从父类继承下来的和本身拥有的字段*
>
>3.对齐填充 Padding

## 对象的访问定位

*通过栈上reference访问 对象引用有堆空间的对象的地址引用 而堆的对象有方法区中类元信息的引用*

> 对象的两种访问方式 : 句柄访问  直接指针
>
> 1.句柄访问
>
> *缺点 : 在堆空间中开辟了一块空间 会占用空间 ; 通过两次指针访问才能访问到堆中的对象*
>
> *优点: reference中存储稳定句柄地址 对象被移动时只会改变句柄中实例数据指针即可 reference;本身不需要被修改*
>
> 2.直接指针(HotSpot采用)
>
> *缺点: 对象被移动时需要修改reference的值*
>
> *优点: 直接指针是局部变量表中的引用 直接指向堆中的实例 在对象实例中有类型指针 指向方法区的对象类型数据; 不用句柄占用空间*