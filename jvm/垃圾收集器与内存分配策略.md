# 垃圾收集器与内存分配策略

## 对象已死？

*对堆进行回收前 第一件事就是确定哪些对象还“活着”。哪些对象已经“死亡”*

### 引用计数算法

> 在对象中添加一个引用计数器 每当有一个地方引用它 计数器就加一；引用失效时，计数器就减一；任何时刻计数器为0的对象就是不可能再被使用的。
>
>  4669K->536K(251392K)  说明Java虚拟机并不是这个算法

### 可达性分析算法

> 通过一系列 “GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索 搜索过程所走过的路径称为 “引用链” 。 如果某个对象到GC Roots件没有任何引用链相连，即从GC Roots到这个对象不可达 说明该对象是不可能再被使用的

**可作为GC Roots的对象**

> 1.在虚拟机栈中引用的对象 比如 各个线程被调用的方法堆栈中用到的参数 局部变量 临时变量等
>
> 2.方法区中类静态属性引用的对象
>
> 3.方法区中常量引用的对象。比如字符串常量池里的引用
>
> 4.本地方法栈中JNI引用的对象
>
> 5.Java虚拟机内部的引用  如基本数据类型的Class对象、常驻异常对象、系统类加载器
>
> 6.被同步锁(synchronized)持有的对象
>
> 7.反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等

### 再谈引用

*Java将引用分为强引用、软引用、弱引用、虚引用*

>1.强引用 ： 最传统的 引用 的定义 即 Object obj = new Object() 无论任何情况下 只要强引用关系还存在 垃圾回收器就永远不会回收掉被引用的对象
>
>2.软引用 ： 用来描述一些还有用，但是非必须的对象。 只被软引用关联着的对象，在系统将要发生内存溢出异常之前，会把这些对象列进回收范围之中进行第二次回收 如果这次回收还没有足够的内存 才会抛出内存溢出异常
>
>3.弱引用 ： 用来描述非必须对象 强度比软引用更弱一些。被弱引用关联的对象只能够生存到下一个垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够 都会回收掉只被弱引用关联的对象
>
>4.虚引用 ： 又称为 “幽灵引用” 或 “幻影引用”。它是最弱的一种引用关系。 一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统消息。

### 死亡还是生存？

*通过finalize方法可以自救*



