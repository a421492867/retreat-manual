## 分布式

### 分布式锁的适用场景是什么 有哪些实现方案
> 在分布式架构中  多个线程可能处于不同进程中  而这些线程并发执行遇到资源竞争时 需要分布式锁
> 需要一个分布式锁生成器  分布式系统中的应用程序都可以来使用这个生成器所提供的锁 从而达到多个进程中的线程使用同一把锁
> 主流方案:
> 1.zookeeper: 利用的是zookeeper的临时节点 顺序节点 watch机制来实现  zookeeper分布式锁的特点是高一致性 可以保证CP  所以由它实现的分布式锁更可靠 不会出现混乱
> 2.redis: 利用redis的setnx lua脚本 消费订阅等机制来实现  redis分布式锁的特点是高可用  保证AP  由它实现的分布式锁可能不可靠 不稳定(一旦redis中的数据出现了不一致)  可能出现多个客户端同时加到锁的情况
> 

### 什么是分布式事务 实现方案   (两阶段提交)
> 一次业务处理可能需要多个应用来实现
> 解决方案:
> 1.本地消息表
> 2.消息队列
> 3.Seata
> 

### 什么是CAP理论
> C(Consistency) 强一致性
> A(Available) 可用性
> P(Partition Tolerance) 分区容错性
> 一个分布式系统是必须要保证分区容错性的  在这个前提下 分布式系统要么保证CP 要么保证AP 无法同时保证CAP
> 分区容错性 : 一个系统虽然是分布式的  但对外看上去应该是一个整体  不能由于分布式系统内部的某个节点挂掉 或网络出现故障  而导致系统对外出现异常
> 强一致性 : 一个分布式系统各个节点之间能够及时同步数据  在数据同步过程中 是不能对外提供服务的  不然就会造成数据不一致  所以 强一致性和可用性是不能同时满足的
> 可用性 : 一个分布式系统对外要保证可用
> 
### 什么是BASE理论
> BA : Basically Available 表示基本可用 表示可以允许一定程度的不可用 比如由于系统故障,请求时间变长,或者由于系统故障导致非核心功能不可用 都是允许的
> S : Soft state 表示分布式系统可以处于一种中间状态 比如 数据正在同步
> E : Eventually consistent  表示最终一致性   不要求分布式系统数据实时达到一致  允许在经过一段时间后再达到一致  在达到一致过程中 系统也是可用的
> 
### 什么是服务雪崩 什么是服务限流
> 服务雪崩 : A调用B  B调用C  此时大量请求突然请求A  假设服务A能抗住这些请求 如果C扛不住  C请求堆积 从而B请求堆积 从而A不可用  解决方式是服务降级和服务熔断
> 服务限流 : 在高并发请求下 为了保护系统 可以对访问服务的请求进行数量上的限制 从而防止系统不被大量请求压垮
> 
### 什么是服务熔断 什么是服务降级 区别是什么
> 服务熔断是指  当A调用B不可用时  上游A为了保证自己不受影响 从而不在调用B 直接返回一个结果 减轻A和B的压力 直到B恢复
> 服务降级是指  当发现系统压力过载时 可以通过关闭某个服务 或者限流某个服务来减轻系统压力
> 
> 相同点 : 1.都是为了防止系统崩溃  2.都是让用户体验到某功能暂时不可用
> 不同点 : 熔断是下游服务故障触发的  降级是为了降低系统负载