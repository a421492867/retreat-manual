### 索引

1. B-Tree索引

``` 实际是B+Tree 即每个叶子节点都包含指向下一个叶子节点的指针   B-Tree索引能够加快访问数据速度 因为存储引擎不再需要进行全表扫描来获取需要的数据  取而代之的是从索引的根节点开始进行搜索  根节点的槽中存放了指向子节点的指针 存储引擎根据这些指针向下层查找 通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点 这些指针实际上定义了子节点页中值得上限和下限 最终存储引擎要么是找到对应值 要么该记录不存在  叶子结点比较特殊 他们的指针指向的是被索引的数据 而不是其他的节点页```

``` 可以使用B-Tree索引的查询类型 : 全值匹配  匹配最左前缀  匹配列最左前缀  匹配范围值  精确匹配某一列并范围匹配另一列  只访问索引的查询```

``` B-Tree索引限制  :  如果不是按照索引的最左列开始查找 则无法使用索引   不能跳过索引中的列   如果查询中某个列有范围查询 则其右边的所有列都无法使用索引优化查询```

2.哈希索引
3.空间数据索引(R-Tree)
4.全文索引
5.其他索引


#### 高性能索引策略

1.独立的列
``` 指的是索引列不能是表达式的一部分  也不能是函数的参数  例如 select actor_id from sakila.actor where actor_id + 1 = 5;```

2.前缀索引和索引的选择性
``` 索引开始的部分字符 可以节约索引空间 从而提高索引效率 但也降低了索引的选择性    索引选择性 : 不重复的索引值(基数)和数据表的记录总数(#T)的比值  唯一索引的选择性是1   前缀索引是一种能使索引更小、更快的有效方法 但另一方面也有缺点 : MySQL无法使用前缀索引做ORDER BY 和 GROUP BY 也无法使用前缀索引做覆盖扫描```

3.多列索引

4.选择合适的索引列顺序

5.聚簇索引
``` 并不是一种单独的索引类型  而是一种数据存储方式 具体细节依赖其实现方式  InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行  当表有聚簇索引时,它的数据行实际上存放在索引的叶子页中 一个表只能有一个聚簇索引```
``` InnoDB通过主键聚集数据 如果没有定义主键 会选择一个唯一的非空索引代替 如果没有这样的索引 会隐式定义一个主键作为聚簇索引```

6.覆盖索引
``` 如果一个索引包含(覆盖)所有需要查询的字段的值 就称为覆盖索引```