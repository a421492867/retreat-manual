# MySQL

## 一条MySQL语句执行的步骤

> 1.客户端请求 -> 连接器
>
> 2.查询缓存(存在缓存则直接返回  不存在则执行后续操作)
>
> 3.分析器(对SQL进行词法分析和语法分析操作)
>
> 4.优化器(主要对执行的SQL优化选择最优的执行方案)
>
> 5.执行器 -> 去引擎层获取数据返回

## 索引的三种常见底层数据结构以及优缺点

> 三种常见索引底层结构 : 哈希表    有序数组    搜索树
>
> 哈希表:适用于等值查询 不适合范围查找
>
> 有序数组:适用于静态存储引擎  等值和范围查找性能好 但是更新数据成本高
>
> N叉树

## 索引的常见类型以及如何发挥作用

> 根据叶子节点的内容 索引类型分为   主键索引    和   非主键索引
>
> 1.主键索引的叶子节点 存的整行数据  在InnoDB里被称为聚簇索引
>
> 2.非主键索引叶子节点  存的主键的值  在InnoDB里称为二级索引

## MyISAM和InnoDB实现B树索引方式的区别是什么

> InnoDB存储引擎 : B+树索引的叶子节点保存数据本身  其数据文件本身就是索引文件
>
> MyISAM存储引擎 : B+树索引的叶子节点保存数据的物理地址 叶节点的data域存放的是数据记录的地址 索引文件和数据是分离的

## 什么是覆盖索引和索引下推

> 覆盖索引 : 在某个查询里 索引 K 已经覆盖了我们的查询要求  
>
> 索引下推 : 可以在索引遍历过程中  对索引中包含的字段优先做判断  直接过滤掉不满足条件的记录 减少回表次数



## MySQL的 change buffer是什么

> 当需要更新一个数据页时,如果数据页在内存中就直接更新;而如果这个数据页还没有在内存中的话,在不影响数据一致性的前提下,InnoDB会将这些操作缓存在 change buffer中
>
> 这样就不需要从磁盘读入这些数据页了 在下次查询需要访问这个数据页的时候 将数据页读入内存  然后执行change buffer中与这个页有关的操作  通过这种方式能保证这个数据逻辑的正确性
>
> 唯一索引的更新不能使用change buffer 只有普通索引可以使用



## MySQL如何判断一行扫描数

> MySQL在真正开始执行语句之前 并不能准确的知道满足这个条件的记录有多少条 只能根据统计信息来估算 这个统计信息就是索引的  区分度



## MySQL redo log 和 bin log

|                | redo log                                      | binlog                                                       |
| -------------- | --------------------------------------------- | ------------------------------------------------------------ |
| 作用           | 用于崩溃恢复                                  | 主从复制和数据恢复                                           |
| 实现方式       | Innodb存储引擎实现                            | Server层实现 所有的存储引擎都可以使用binlog                  |
| 记录方式       | 循环写的方式记录 写到结尾时, 会回头循环写日志 | 通过追加的方式记录 当文件尺寸大于配置值后   ,后续日志会记录在新的文件上 |
| 文件大小       | redo log大小固定                              | 通过配置指定                                                 |
| crash-safe能力 | 具有                                          | 没有                                                         |
| 日志类型       | 逻辑日志                                      | 物理日志                                                     |

## 为什么需要redo log

> redo log主要用于MySQL异常重启后的一种数据恢复手段 确保数据一致性
>
> MySQL进行更新操作 为了能够快速响应 采用了异步写回磁盘的技术 写入内存后就返回 .但是这样 会存在crash后内存数据丢失的隐患 而 redo log具备crash-safe的能力

## 为什么 redo log具有crash-safe的能力  是binlog无法替代的

> redo log可以确保InnoDB判断哪些数据已经刷盘 哪些数据还没有
>
> redo log和binlog有一个很大的区别是  redolog循环写 binlog追加写  也就是说redo log只会记录未刷盘的日志 已经刷入磁盘的数据都会从redo log这个有限大小的日志文件里删除   binlog是追加日志 保存全量日志
>
> 当数据库crash后  想要恢复未刷盘但是已经写入redo log 和 binlog的数据到内存时, binlog是无法恢复的.因为binlog无法让InnoDB判断哪些已经刷盘 哪些还没有
>
> 如果redo log写入失败  说明此次操作失败 事务也不可能提交

## 当数据库crash后 如何恢复未刷盘的数据到内存

> 根据redo log 和binlog的两阶段提交  未持久化的数据分为几种情况
>
> 1.change buffer 写入  redo log虽然做了fsync 但未commit, binlog未fsync到磁盘 这部分数据丢失
>
> 2.change buffer写入  redo log fsync未commit, binlog 已经fsync到磁盘 先从binlog 恢复 redo log 再从redo log恢复 change buffer
>
> 3.change buffer写入 redo log 和 binlog 都fsync  直接从redolog恢复