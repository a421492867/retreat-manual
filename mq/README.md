## 消息队列

### 消息队列有哪些作用
> 解耦  使用消息队列作为两个系统之间的通讯方式  两个系统不需要相互依赖了
> 异步  系统A给消息队列发送完消息之后  就可以继续做其他事情了
> 流量削峰  如果使用消息队列的方式来调用某个系统  那么消息在队列中排队  由消费者自己控制消费速度
> 
> 
### 死信队列是什么  延时队列是什么
> 死信队列   用来存放那些没有成功消费的消息  通常可以用来作为消息重试
> 延时队列   用来存放需要在指定时间被处理的元素的队列  通常可以用来处理一些具有过期性操作的业务 比如十分钟内未支付则取消订单
> 
> 
### Kafka为什么比RocketMQ的吞吐量高
> Kafka的生产者采用的是异步发送消息机制  当发送一条消息时  消息并没有发送到Broker而是缓存起来 然后直接向业务返回成功 当缓存的消息达到一定数量时再批量发送给Broker 这种做法减少了网络io 从而提高了消息发送的吞吐量  但如果消息生产者宕机 会导致消息丢失 业务出错  所以理论上Kafka利用此机制提高了性能却降低了可靠性
> 


### Kafka的pull和push分别有什么优缺点
> pull表示消费者主动拉取  可以批量拉取 也可以单条拉取 由消费者自己控制 根据自己消息处理能力来进行控制 但是消费者不能及时知道是否有消息 可能会拉到的消息为空
> push表示Broker主动给消费者推送消息 所以肯定是有消息时才会推送  但是消费者不能按自己的能力来消费消息 推过来多少消息 消费者就消费多少消息 可能造成网络阻塞 消费者压力大等问题
> 

### RocketMQ的底层实现原理
> RocketMQ由NameServer集群 Producer集群 Consumer集群 Broker集群组成  消息生产和消费大致原理如下:
> 1.Broker在启动时候向所有NameServer注册 并保持长连接 每30秒发送一次心跳
> 2.Producer在发送消息的时候从NameServer获取Broker服务器地址 根据负载均衡算法选择一台服务器来发消息
> 3.Consumer消费消息的时候同样从NameServer获取Broker地址 然后主动拉取消息来消费
> 

### 消息队列如何保证消息可靠传输
> 消息可靠传输代表 既不能多 也不能少
> 1.为了保证消息不多  也就是消息不能重复  也就是生产者不能重复生产消息 或者 消费者不能重复消费消息
> 2.首先要确保消息不多发 这个不常出现 也比较难控制 如果出现了多发 很大原因是生产者自己的原因 如果要避免出现问题 就要在消费端做控制
> 3.避免不重复消费 最保险的机制就是消费者实现幂等性  保证就算重复消费 也不会有问题 通过幂等性 也能解决生产者重复发送消息的问题
> 4.消息不能少 意思就是消息不能丢失  生产者发送的消费  消费者一定要能消费到
> 5.生产者发送消息时 要确认Broker确实收到并持久化了这条消息 比如RabbitMQ的confirm机制, Kafka的ack机制
> 6.broker要等待消费者真正确认消费到了消息才删掉消息 这里通常就是消费端ack机制  消费者接收到一条消息后 如果确认没问题了  就可以给broker发送一个ack broker接到ack后才会删除消息