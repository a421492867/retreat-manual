## Redis


### Redis有哪些数据结构  分别有哪些典型的应用场景
> 1.字符串  可以用来做最简单的数据 还可以缓存某个简单的字符串    Redis分布式锁 还可以实现计数器 Session共享  分布式ID
> 2.哈希表  可以用来存储一些key-value对 更适合来存储对象
> 3.列表  Redis的列表通过命令的组合 既可以当做栈 也可以当做队列来使用  可以用来缓存 类似 微信公众号  微博等消息流数据
> 4.集合  和列表类似 也可以存储多个元素 但元素不能重复  可以进行 交集 并集  差集操作  实现类似 我和某人共同关注的人  朋友圈点赞等
> 5.有序集合  有序集合可以设置顺序  实现排行榜
> 
### Redis分布式锁底层如何实现
> 1.首先利用setnx来保证  如果key不存在才能获取到锁  如果key存在 则获取不到锁
> 2.还要利用lua脚本来保证多个redis操作的原子性
> 3.同时还要考虑锁国企  所以需要额外一个定时任务来监听锁是否需要续约
> 4.还要考虑redis节点挂掉后的情况  需要采用红锁的方式来同时向 N/2 + 1个节点申请锁 都申请到了才证明获取锁成功 这样就算其中某个redis节点挂掉 锁也不能被其他客户端获得到
> 
### redis主从复制的核心原理
> redis主从复制是提高redis的可靠性的有效措施 流程如下:
> 1.集群启动时 主从库间先建立连接 为全量复制做准备
> 2.主库将所有数据同步给从库  从库收到数据后 在本地完成数据加载 这个过程依赖于内存快照RDB
> 3.在主库将数据同步给从库的过程中  主库不会阻塞 仍然可以正常接收请求. 这些请求中的写操作并没有记录到刚刚的RDB文件中 为了保证主从库的数据一致性  主库会在内存中用专门的replication buffer 记录RDB文件生成过程中收到的所有写操作
> 4.最后 也就是第三阶段  主库会把第二阶段执行过程中新收到的写命令 再发送给从库 . 当主库完成RDB文件发送后  就会把此时replication buffer中修改操作发给从库 从库再执行这些操作  这样一来 主从库就实现同步了
> 5.后续主库和从库都可以处理客户端读操作 写操作只能交给主库  主库接收到写操作后  还会将写操作发送给从库 实现增量同步
> 
### 缓存穿透 缓存击穿 缓存雪崩
> 缓存雪崩 : 如果缓存中某一时刻大批热点数据同时过期 那么就可能导致大量请求直接访问数据库   解决办法: 在过期时间上增加一点随机值  / 搭建一个高可用的redis集群
> 缓存击穿 : 某一个热点key突然失效 也导致大量请求直接访问数据库    解决方案  考虑这个key不设过期时间
> 缓存穿透 : 加入某一时刻访问redis的大量key都不在redis中  那么也会给数据库造成压力  解决方案是 使用布隆过滤器 如果它认为一个key不存在 那么这个key肯定不存在  拦截不存在的key
> 
### redis和mysql如何保证数据一致
> 1.先更新mysql 在更新redis 如果更新redis失败可能不一致
> 2.先删除redis缓存数据 在更新mysql  再次查询的时候再将数据添加到缓存中 解决1中的问题 但在高并发下性能较低 而且仍然会出现数据不一致问题  比如线程1删除了redis缓存数据 正在更新mysql  此时另外一个查询再查询 那么就会把mysql中老数据又查到redis
> 3.延时双删  先删除redis缓存数据 在更新mysql 延迟几百毫秒再删除redis缓存数据 这样就算在更新mysql时 有其他线程读了mysql 也不会产生2中的问题  从而保持一致